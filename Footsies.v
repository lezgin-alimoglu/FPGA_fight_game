//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Footsies(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO0GPIO,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO1GPIO
);


    //=======================================================
    //  REG/WIRE declarations
    //=======================================================
    wire        clk_25Mhz;
    wire        clk_60hz;
    wire [9:0]  next_x;
    wire [9:0]  next_y;
    wire [3:0]  state1;
    wire [3:0]  state2;
    wire [7:0]  char_pixel;
    wire [7:0]  bg_pixel;
    wire [7:0]  final_pixel;
    wire [3:0]  keypad_rows;
    wire [3:0]  keypad_cols;
    wire fwd2;
    wire bwd2;
    wire attack2;
    wire up2;
    wire [1:0]  health1;
    wire [1:0]  health2;
    wire game_over;
    wire [7:0]  time_display;
    wire [7:0]  health_display;
    
    // Game state machine signals
    wire [3:0]  game_state;
    wire        game_mode;
    wire        game_start;
    wire [1:0]  winner;
    wire [3:0]  countdown;
    wire [3:0]  hex0_data;
    wire [3:0]  hex1_data;
    wire [3:0]  hex2_data;
    wire [3:0]  hex3_data;
    wire [3:0]  hex4_data;
    wire [3:0]  hex5_data;
    wire [9:0]  ledr_state;
    wire [1:0] block1;
    wire [1:0] block2;

    reg [15:0] bot_lfsr = 16'hACE1;
    reg bot_fwd, bot_bwd, bot_attack;
    always @(posedge clk_60hz) begin
        bot_lfsr <= {bot_lfsr[14:0], bot_lfsr[15] ^ bot_lfsr[13] ^ bot_lfsr[12] ^ bot_lfsr[10]};
        bot_fwd <= bot_lfsr[0];
        bot_bwd <= bot_lfsr[1];
        bot_attack <= bot_lfsr[2];
    end

    wire fwd2_mux = (game_mode == 1'b0) ? bot_fwd : fwd2;
    wire bwd2_mux = (game_mode == 1'b0) ? bot_bwd : bwd2;
    wire attack2_mux = (game_mode == 1'b0) ? bot_attack : attack2;

	// Columns as outputs to keypad
	assign GPIO0GPIO[0] = keypad_cols[0]; // C4
	assign GPIO0GPIO[1] = keypad_cols[1]; // C3
	assign GPIO0GPIO[2] = keypad_cols[2]; // C2
	assign GPIO0GPIO[3] = keypad_cols[3]; // C1

	// Rows as inputs from keypad
	assign keypad_rows[0] = GPIO0GPIO[4]; // R1
	assign keypad_rows[1] = GPIO0GPIO[5]; // R2
	assign keypad_rows[2] = GPIO0GPIO[6]; // R3
	assign keypad_rows[3] = GPIO0GPIO[7]; // R4

	
	//=========================================
	// 	GAME MENU
	//=========================================
	
	localparam MODE_MENU = 1'b0;
	localparam MODE_PLAY = 1'b1;

	reg mode_state;
	wire menu_select;
	wire menu_up;
	wire menu_down;



    //=======================================================
    //  Structural coding
    //=======================================================

    // background renderer
    background_renderer bg (
        .vga_x   (next_x),
        .vga_y   (next_y),
        .bg_pixel(bg_pixel)
    );

    // 25 MHz clock
    clock_divider #(.DIV_FACTOR(2)) my_clock_divider1( 
        .clk    (CLOCK_50),
        .rst    (1'b0),
        .clk_out(clk_25Mhz)
    );

    // 60 Hz clock
    clock_divider #(.DIV_FACTOR(833333)) my_clock_divider2( 
        .clk    (CLOCK_50),
        .rst    (1'b0),
        .clk_out(clk_60hz)
    );
	 
	 
		 
		keypad_controller my_keypad (
			 .clk(clk_60hz),
			 .rows(keypad_rows),
			 .cols(keypad_cols),
			 .fwd(fwd2),
			 .bwd(bwd2),
			 .attack(attack2),
			 .up(up2)
		);


    // game logic & sprite
		 game my_game (
			 .clk         (clk_60hz),
			 .rst         (1'b0),
			 .key         (KEY[0]),
			 .sw_in       (SW[1]),
			 .fwd1        (KEY[3]),
			 .bwd1        (KEY[2]),
			 .attack1     (KEY[1]),
			 .fwd2        (fwd2_mux),
			 .bwd2        (bwd2_mux),
			 .attack2     (attack2_mux),
			 .vga_x       (next_x),
			 .vga_y       (next_y),
			 .sprite_y    (10'd300),
			 .state1      (state1),
			 .state2      (state2),
			 .attacking1  (),
			 .attacking2  (),
			 .pixel_color (char_pixel),
			 .health1     (health1),
			 .health2     (health2),
			 .block1      (block1),
			 .block2      (block2),
			 .game_over   (game_over),
			 .time_display(time_display),
			 .health_display(health_display)
		);

    // Block point display logic (overlay blue rectangles near health bars)
    wire [7:0] block_display;
    assign block_display = ((next_x >= 10 && next_x < 10 + block1 * 10 && next_y >= 50 && next_y < 60) ? 8'b00000011 :
                           (next_x >= 610 - block2 * 10 && next_x < 610 && next_y >= 50 && next_y < 60) ? 8'b00000011 : 8'd0);

    // Menu overlay logic
    wire menu_active = (game_state == 4'd0);
    wire [7:0] menu_pixel =
        (menu_active && next_x >= 220 && next_x < 420 && next_y >= 180 && next_y < 300) ? 8'b11111111 : // White box
        // Draw 'MENU' in black (simple block letters)
        (menu_active && next_y >= 200 && next_y < 220 && next_x >= 260 && next_x < 380) ? 8'b00000000 : // Top bar of letters
        (menu_active && next_y >= 220 && next_y < 260 && (
            (next_x >= 260 && next_x < 280) || // M
            (next_x >= 280 && next_x < 300) || // E
            (next_x >= 300 && next_x < 320) || // N
            (next_x >= 320 && next_x < 340)    // U
        )) ? 8'b00000000 :
        // Draw '1P' or '2P' below
        (menu_active && next_y >= 260 && next_y < 280 && (
            (game_mode == 1'b0 && next_x >= 300 && next_x < 320) || // 1
            (game_mode == 1'b1 && next_x >= 300 && next_x < 320) || // 2
            (next_x >= 320 && next_x < 340) // P
        )) ? 8'b00000000 :
        8'd0;

    // Countdown overlay logic
    wire countdown_active = (game_state == 4'd1);
    wire [7:0] countdown_pixel =
        (countdown_active && next_y >= 200 && next_y < 280 && (
            (countdown == 4'd3 && next_x >= 300 && next_x < 340) || // 3
            (countdown == 4'd2 && next_x >= 320 && next_x < 360) || // 2
            (countdown == 4'd1 && next_x >= 340 && next_x < 380)    // 1
        )) ? 8'b11100000 : // Red number
        (countdown_active && countdown == 4'd0 && next_y >= 200 && next_y < 280 && next_x >= 260 && next_x < 420) ? 8'b00011100 : // Green 'START' bar
        8'd0;

    assign final_pixel = (menu_pixel != 8'd0) ? menu_pixel :
                        (countdown_pixel != 8'd0) ? countdown_pixel :
                        (block_display != 8'd0) ? block_display :
                        (time_display != 8'd0) ? time_display :
                        (health_display != 8'd0) ? health_display :
                        (char_pixel != 8'd0) ? char_pixel :
                        bg_pixel;

		// VGA bağlantıları
		vga_driver draw (
			 .clock    (clk_25Mhz),
			 .reset    (1'b0),
			 .color_in (final_pixel),
			 .next_x   (next_x),
			 .next_y   (next_y),
			 .hsync    (VGA_HS),
			 .vsync    (VGA_VS),
			 .red      (VGA_R),
			 .green    (VGA_G),
			 .blue     (VGA_B),
			 .sync     (VGA_SYNC_N),
			 .clk      (VGA_CLK),
			 .blank    (VGA_BLANK_N)
		);

	 
    // Game state machine
    game_state game_state_inst(
        .clk(CLOCK_50),
        .rst(~KEY[0]),
        .sw0(SW[0]),
        .sw1(SW[1]),
        .key(KEY[0]),
        .p1_any_button(KEY[3] | KEY[2] | KEY[1]),
        .health1(health1),
        .health2(health2),
        .time_counter(time_display),
        .state(game_state),
        .game_mode(game_mode),
        .game_start(game_start),
        .game_over(game_over),
        .winner(winner),
        .countdown(countdown),
        .hex0_data(hex0_data),
        .hex1_data(hex1_data),
        .hex2_data(hex2_data),
        .hex3_data(hex3_data),
        .hex4_data(hex4_data),
        .hex5_data(hex5_data),
        .ledr(ledr_state)
    );

    // Update 7-segment display connections
    hexto7seg hex0(.hex(hex0_data), .hexn(HEX0));
    hexto7seg hex1(.hex(hex1_data), .hexn(HEX1));
    hexto7seg hex2(.hex(hex2_data), .hexn(HEX2));
    hexto7seg hex3(.hex(hex3_data), .hexn(HEX3));
    hexto7seg hex4(.hex(hex4_data), .hexn(HEX4));
    hexto7seg hex5(.hex(hex5_data), .hexn(HEX5));

    // Update LED connections
    assign LEDR = ledr_state;

    //=======================================================
    //  Tie‐offs for unused ports
    //=======================================================
    // SDRAM
    assign DRAM_ADDR  = 13'd0;
    assign DRAM_BA    =  2'd0;
    assign DRAM_CAS_N =  1'b1;
    assign DRAM_CKE   =  1'b0;
    assign DRAM_CLK   =  1'b0;
    assign DRAM_CS_N  =  1'b1;
    assign DRAM_DQ    = {16{1'bz}};
    assign DRAM_LDQM  =  1'b0;
    assign DRAM_RAS_N =  1'b1;
    assign DRAM_UDQM  =  1'b0;
    assign DRAM_WE_N  =  1'b1;



    // GPIO (tri‐state)
    assign GPIO0GPIO = {36{1'bz}};
    assign GPIO1GPIO = {36{1'bz}};

endmodule